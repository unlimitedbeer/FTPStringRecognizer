//
// ex: set ro:
// DO NOT EDIT.
// generated by smc (http://smc.sourceforge.net/)
// from file : recognizer.sm
//


// Initial revision
//


#include "stdafx.h"

using namespace statemap;

// Static class declarations.
MainMap_Preambula MainMap::Preambula("MainMap::Preambula", 0);
MainMap_Username MainMap::Username("MainMap::Username", 1);
MainMap_Server MainMap::Server("MainMap::Server", 2);
MainMap_Domain MainMap::Domain("MainMap::Domain", 3);
MainMap_Zone MainMap::Zone("MainMap::Zone", 4);
MainMap_Error MainMap::Error("MainMap::Error", 5);
MainMap_End MainMap::End("MainMap::End", 6);

void RecognizerState::nil(recognizerContext& context)
{
    Default(context);
}

void RecognizerState::readChar(recognizerContext& context)
{
    Default(context);
}

void RecognizerState::Default(recognizerContext& context)
{
    throw (
        TransitionUndefinedException(
            context.getState().getName(),
            context.getTransition()));

}

void MainMap_Preambula::readChar(recognizerContext& context)
{
    Recognizer& ctxt = context.getOwner();

    if (ctxt.isPreambulaFinished())
    {
        context.getState().Exit(context);
        context.clearState();
        try
        {
            ctxt.preambulaPassed();
            context.setState(MainMap::Username);
        }
        catch (...)
        {
            context.setState(MainMap::Username);
            throw;
        }
        context.getState().Entry(context);
    }
    else if (ctxt.isPreambulaCorrect())

    {
        context.getState().Exit(context);
        context.clearState();
        try
        {
            ctxt.preambulaReading();
            context.setState(MainMap::Preambula);
        }
        catch (...)
        {
            context.setState(MainMap::Preambula);
            throw;
        }
        context.getState().Entry(context);
    }
    else
    {
        context.getState().Exit(context);
        context.clearState();
        try
        {
            ctxt.ShowError();
            context.setState(MainMap::Error);
        }
        catch (...)
        {
            context.setState(MainMap::Error);
            throw;
        }
        context.getState().Entry(context);
    }

}

void MainMap_Username::readChar(recognizerContext& context)
{
    Recognizer& ctxt = context.getOwner();

    if (ctxt.isUsernameFinished())
    {
        context.getState().Exit(context);
        context.clearState();
        try
        {
            ctxt.usernamePassed();
            context.setState(MainMap::Server);
        }
        catch (...)
        {
            context.setState(MainMap::Server);
            throw;
        }
        context.getState().Entry(context);
    }
    else if (ctxt.isUsernameCorrect())

    {
        context.getState().Exit(context);
        context.clearState();
        try
        {
            ctxt.usernameReading();
            context.setState(MainMap::Username);
        }
        catch (...)
        {
            context.setState(MainMap::Username);
            throw;
        }
        context.getState().Entry(context);
    }
    else
    {
        context.getState().Exit(context);
        context.clearState();
        try
        {
            ctxt.ShowError();
            context.setState(MainMap::Error);
        }
        catch (...)
        {
            context.setState(MainMap::Error);
            throw;
        }
        context.getState().Entry(context);
    }

}

void MainMap_Server::readChar(recognizerContext& context)
{
    Recognizer& ctxt = context.getOwner();

    if (ctxt.isServerFinished())
    {
        context.getState().Exit(context);
        context.clearState();
        try
        {
            ctxt.serverPassed();
            context.setState(MainMap::Domain);
        }
        catch (...)
        {
            context.setState(MainMap::Domain);
            throw;
        }
        context.getState().Entry(context);
    }
    else if (ctxt.isServerCorrect())

    {
        context.getState().Exit(context);
        context.clearState();
        try
        {
            ctxt.serverReading();
            context.setState(MainMap::Server);
        }
        catch (...)
        {
            context.setState(MainMap::Server);
            throw;
        }
        context.getState().Entry(context);
    }
    else
    {
        context.getState().Exit(context);
        context.clearState();
        try
        {
            ctxt.ShowError();
            context.setState(MainMap::Error);
        }
        catch (...)
        {
            context.setState(MainMap::Error);
            throw;
        }
        context.getState().Entry(context);
    }

}

void MainMap_Domain::readChar(recognizerContext& context)
{
    Recognizer& ctxt = context.getOwner();

    if (ctxt.isDomainFinished())
    {
        context.getState().Exit(context);
        context.clearState();
        try
        {
            ctxt.domainPassed();
            context.setState(MainMap::Zone);
        }
        catch (...)
        {
            context.setState(MainMap::Zone);
            throw;
        }
        context.getState().Entry(context);
    }
    else if (ctxt.isStringFinished())

    {
        context.getState().Exit(context);
        context.clearState();
        try
        {
            ctxt.domainPassed();
            context.setState(MainMap::End);
        }
        catch (...)
        {
            context.setState(MainMap::End);
            throw;
        }
        context.getState().Entry(context);
    }
    else if (ctxt.isDomainCorrect())

    {
        context.getState().Exit(context);
        context.clearState();
        try
        {
            ctxt.domainReading();
            context.setState(MainMap::Domain);
        }
        catch (...)
        {
            context.setState(MainMap::Domain);
            throw;
        }
        context.getState().Entry(context);
    }
    else
    {
        context.getState().Exit(context);
        context.clearState();
        try
        {
            ctxt.ShowError();
            context.setState(MainMap::Error);
        }
        catch (...)
        {
            context.setState(MainMap::Error);
            throw;
        }
        context.getState().Entry(context);
    }

}

void MainMap_Zone::readChar(recognizerContext& context)
{
    Recognizer& ctxt = context.getOwner();

    if (ctxt.isZoneFinished())
    {
        context.getState().Exit(context);
        context.clearState();
        try
        {
            ctxt.zonePassed();
            context.setState(MainMap::End);
        }
        catch (...)
        {
            context.setState(MainMap::End);
            throw;
        }
        context.getState().Entry(context);
    }
    else if (ctxt.isZoneCorrect())

    {
        context.getState().Exit(context);
        context.clearState();
        try
        {
            ctxt.zoneReading();
            context.setState(MainMap::Zone);
        }
        catch (...)
        {
            context.setState(MainMap::Zone);
            throw;
        }
        context.getState().Entry(context);
    }
    else
    {
        context.getState().Exit(context);
        context.clearState();
        try
        {
            ctxt.ShowError();
            context.setState(MainMap::Error);
        }
        catch (...)
        {
            context.setState(MainMap::Error);
            throw;
        }
        context.getState().Entry(context);
    }

}

void MainMap_Error::nil(recognizerContext& context)
{


}

void MainMap_End::nil(recognizerContext& context)
{


}

//
// Local variables:
//  buffer-read-only: t
// End:
//
